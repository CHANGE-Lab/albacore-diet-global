---
title: "Albacore_mvwork"
author: "Natasha Hardy"
date: "April 27, 2020"
output: html_document
---

This document is for cluster analyses and multivariate analyses of the global albacore diet contents and review.

```{r Setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/natasha/Documents/POSTDOC/TUNA DIETS/TUNASTATS/data")
```

```{r Worspace}

# Workspace setup ----
getwd()

#The code used Friday 8th Nov mainly involved the vegan and klaR packages. So you should only need
#to load those out of the list below.

#install what needs to be installed
#install.packages("fpc")
#install.packages("labdsv")
#install.packages("MVPARTwrap") #notice that this didn't work
library(devtools)
install_github('kassambara/factoextra')
install.packages("ggdendro")
install.packages("circlize")

#some packages are on GitHub and not on the CRAN project yet
#install.packages("devtools") 
#library(devtools)
#install_github("cran/mvpart")
#install_github("cran/MVPARTwrap")

devtools::install_github("jakelawlor/PNWColors") 

#load all packages required
library(tidyverse)
library(vegan)
library(klaR)
library(dplyr)
library(cluster)
library(fpc)
library(ggplot2)
library(reshape2)
library(purrr)
library("dendextend")
library("PNWColors")
library(factoextra)
library(ggdendro)
library(circlize)
library(plyr)
library(viridis)

#Not required, parking lot here
#library(ade4)
#library(gclus)
#library(RColorBrewer)
#library(labdsv)
#library(mvpart)
#library(MVPARTwrap)

```

## Cluster Analyses

Useful resource for this and where a lot of the code came from:

### Hierarchical clustering tutorial by Anastasia Reusova ----
Tutorial notes & code found here: 
https://towardsdatascience.com/hierarchical-clustering-on-categorical-data-in-r-a27e578f2995

### Prey & traits for cluster ----

```{r Load data for cluster analyses}

#Species traits df

spe_traitord <- read.csv("/Users/natasha/Documents/POSTDOC/TUNA DIETS/TUNASTATS/data/data_2019/prey_traits_cats.csv", row.names = 1, header=TRUE)
View(spe_traitord) #241 and 9

```


```{r Data manip for cluster analyses}

#Create new df to modify & remove NA's
spe_traitsO = spe_traitord %>%
  drop_na()
dim(spe_traitsO) #220 and 13

#Can save this to reload if needed
#write.csv(spe_traitsO, "spe_traitsO.csv")
#spe_traits2 <- read.csv("spe_traitsO.csv", header=TRUE)
#View(spe_traitsO)

str(spe_traitsO)

#Could relabel variables?
#spe_traitsO2 = spe_traitsO %>% 
#  dplyr::rename(`vertical habitat` = `vert_habitat`, 
#                `horizontal habitat` = `horz_habitat`,
#                `diel migrant` = `diel_migrant_cat`, 
#                `season migrant` = `season_cat`, 
#                `refuge use` = `refuge_cat
#                `body shape` = `body_shape_ordinal`,
#                `physical defense` = `phys_defense`)
#str(spe_traitsO2)

speciesO = spe_traitsO$prey_sp
ctraitsO = spe_traitsO[,6:13]
str(ctraitsO)
## Data manipulation for heatmaps
#Probably don't need to do this as this was for previous ordinal data and we're now using categorical

#rm(spe_traits2)

```


```{r Data manip - add rownames for dendrogram}

#Row name as column datasets
#Check, found no rownames initially: rownames(spe_traitO)
#Add column for row names
spe_traitsrow <- spe_traitsO
names <- rownames(spe_traitsrow)
#Bind and rename to "dendlabs" for later
spe_traitsO <- cbind(names, spe_traitsrow)
names(spe_traitsO)[names(spe_traitsO)=="names"] <- "dendlabs"

```

### Compare cluster techniques ----

```{r Cluster analyses}

#### Distance matrices ----

alb.gower.dist <- daisy(ctraitsO, metric = c("gower"))
dim(ctraitsO) #220 species, 8 traits


#### Divisive cluster ----
alb.divisive.clust <- diana(as.matrix(alb.gower.dist), 
                        diss = TRUE, keep.diss = TRUE)
plot(alb.divisive.clust, main = "Divisive")


#### Agglomerative cluster ----
#Use "average" or "complete" linkage
#ADD NOTE ON AVE VS. COMPLETE LINKAGE
alb.aggl.clustc <- hclust(alb.gower.dist, method = "complete")
plot(alb.aggl.clustc, main = "Agglomerative, complete linkages")

```

```{r Cluster stat table function}

# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive 
library(fpc)
cstats.table <- function(dist, tree, k) {
  clust.assess <- c("cluster.number","n","within.cluster.ss","average.within","average.between",
                    "wb.ratio","dunn2","avg.silwidth")
  clust.size <- c("cluster.size")
  stats.names <- c()
  row.clust <- c()
  output.stats <- matrix(ncol = k, nrow = length(clust.assess))
  cluster.sizes <- matrix(ncol = k, nrow = k)
  for(i in c(1:k)){
    row.clust[i] <- paste("Cluster-", i, " size")
  }
  for(i in c(2:k)){
    stats.names[i] <- paste("Test", i-1)
    
    for(j in seq_along(clust.assess)){
      output.stats[j, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]
      
    }
    
    for(d in 1:k) {
      cluster.sizes[d, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]
      dim(cluster.sizes[d, i]) <- c(length(cluster.sizes[i]), 1)
      cluster.sizes[d, i]
      
    }
  }
  output.stats.df <- data.frame(output.stats)
  cluster.sizes <- data.frame(cluster.sizes)
  cluster.sizes[is.na(cluster.sizes)] <- 0
  rows.all <- c(clust.assess, row.clust)
  # rownames(output.stats.df) <- clust.assess
  output <- rbind(output.stats.df, cluster.sizes)[ ,-1]
  colnames(output) <- stats.names[2:k]
  rownames(output) <- rows.all
  is.num <- sapply(output, is.numeric)
  output[is.num] <- lapply(output[is.num], round, 2)
  output
}

```

```{r Cluster Assessment Tables}

#### Cluster method assessment ----

#Stats table for divisive method
alb.stats.df.divisive <- cstats.table(alb.gower.dist, alb.divisive.clust, 10)
alb.stats.df.divisive

#Stats table for agglomerative method
alb.stats.df.aggl <- cstats.table(alb.gower.dist, alb.aggl.clustc, 10) 
#complete linkages looks like the most balanced approach
alb.stats.df.aggl

#The average between metric is tighter for agglomerative whilst the average within is tighter 
#for divisive. # MEANING of above statement?
#Conceptually, we want to aggregate prey species and am thus selecting an agglomerative technique.
```

```{r Cluster Selection - Divisive}

### Using "Elbow" and "Silhouette" methods to identify the best number of clusters

#Assessment of clustering analyses reveals the minimum optimal clusters = 7, and up to 15.
#Selected --> 10 because of cluster evenness
#I want to choose a reasonable number, based on which I will be able to see basic 
#differences between customer groups as a result

### Elbow method
#Divisive clustering
ggplot(data = data.frame(t(cstats.table(alb.gower.dist, alb.divisive.clust, 20))), 
       aes(x=cluster.number, y=within.cluster.ss)) + 
  geom_point()+
  geom_line()+
  ggtitle("Divisive clustering") +
  labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
  theme(plot.title = element_text(hjust = 0.5))
#10 looks like the proper "elbow" in this graph

### Silhouette
#When it comes to silhouette assessment, the rule is you should choose the number that maximizes the silhouette coefficient because you want clusters that are distinctive (far) enough to be considered separate.

#Divisive
ggplot(data = data.frame(t(cstats.table(alb.gower.dist, alb.divisive.clust, 20))), 
       aes(x=cluster.number, y=avg.silwidth)) + 
  geom_point()+
  geom_line()+
  ggtitle("Divisive clustering") +
  labs(x = "Num.of clusters", y = "Average silhouette width") +
  theme(plot.title = element_text(hjust = 0.5))
#10

```

```{r Cluster Selection - Agglomerative}

### Using "Elbow" and "Silhouette" methods to identify the best number of clusters

#Agglomerative clustering,provides a more ambiguous picture
ggplot(data = data.frame(t(cstats.table(alb.gower.dist, alb.aggl.clustc, 20))), 
       aes(x=cluster.number, y=within.cluster.ss)) + 
  geom_point()+
  geom_line()+
  ggtitle("Agglomerative clustering") +
  labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
  theme(plot.title = element_text(hjust = 0.5))
#Seeing 8-10 clusters

### Silhouette
#When it comes to silhouette assessment, the rule is you should choose the number that maximizes the silhouette coefficient because you want clusters that are distinctive (far) enough to be considered separate.

#Agglomerative
ggplot(data = data.frame(t(cstats.table(alb.gower.dist, alb.aggl.clustc, 20))), 
       aes(x=cluster.number, y=avg.silwidth)) + 
  geom_point()+
  geom_line()+
  ggtitle("Agglomerative clustering") +
  labs(x = "Num.of clusters", y = "Average silhouette width") +
  theme(plot.title = element_text(hjust = 0.5))
#8-12 clusters optimal

##Ultimately selected 10 because it was the median number for agglomerative clustering method 
#between the elbow and the silhouette assessments

```
## OLD Data

### Cluster Dendrograms ---

```{r Horizontal dendrogram}

#Using agglomerative hierarchical clustering, k = 10
PNW.pal8 <- pnw_palette(8, name = "Bay", type = "continuous")
str(PNW.pal)

alb.dendro <- as.dendrogram(alb.aggl.clustc) #241 species

#Horizontal cluster illustration version
alb.dendro.col <- alb.dendro %>%
  #set("branches_k_color", k = 10, value = PNW.pal) %>%
  set("branches_k_color", k = 8, value = PNW.pal8) %>%
  set("branches_lwd", 0.8) %>%
  set("labels", speciesO) %>% #NOT VERY LEGIBLE...
  set("labels_colors", 
      value = c("darkslategray")) %>% 
  set("labels_cex", 0.5)
alb.ggd1 <- as.ggdend(alb.dendro.col)
alb.dendro.graph <- ggplot(alb.ggd1, theme = theme_minimal()) +
  labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 8")
alb.dendro.graph
ggsave('adult.dendro.horz.k8.old.png', plot=adult.dendro.graph, width=8, height=8, dpi=300)

```

```{r Radial dendrogram}

# Radial plot looks less cluttered (and cooler)
alb.dendro.rad <- ggplot(alb.ggd1, labels = FALSE) + 
  scale_y_reverse(expand = c(0.2, 0)) +
  coord_polar(theta="x")
alb.dendro.rad 
#No labels on this one, labels were too cluttered/problems

#Save radial dendrogram for chat
#ggsave('alb.dendro.rad.png', plot=alb.dendro.rad, width=8, height=8, dpi=300)
ggsave('adult.dendro.rad.k8.old.png', plot=alb.dendro.rad, width=8, height=8, dpi=300)

```

```{r Vertical dendrogram}

#similar to https://stackoverflow.com/questions/38034663/rotate-labels-for-ggplot-dendrogram 

# This is a different way to compute hierarchical clustering and cut the tree
#clus <- hcut(mydist, k = 6, hc_func = 'hclust', hc_method = 'ward.D2', graph = FALSE, isdiss = TRUE)

## For a horizontal version below
#dend <- as.dendrogram(alb.aggl.clustc)
#Use alb.dendro

#Below is problematic0
#labels(dend) <- paste0(paste0(rep('', 3), collapse = ''), speciesO)
#dend <- sort(dend, decreasing = FALSE)
#View(labels(dend))

#Creating df for the dend labels so that we can accurately line them up with the species
dendlabs <- labels(alb.dendro) #Need to create strings of labels to manipulate
dendlabs2 <- as.data.frame(dendlabs) #turn in df

#Join these data so we can relabel the dendrogram
#Use plyr function because it conserves the row order of the left df, which matters for assigning labels here
library(plyr)
dfdend <- join(dendlabs2, spe_traitsO)

ggd1 <- ggplot(dend %>%
                 set("branches_k_color", k = 10, value = 
                       c("#00496F", "#066384", "#0D7E9A", "#59A082", "#BBC45A",
                         "#EDC636", "#EDA417", "#EB8203", "#E46113", "#DD4124")) %>%
                 set("branches_lwd", 0.6) %>%
                 set("labels", dfdend$prey_sp) %>% #NOT VERY LEGIBLE...
                 set("labels_colors", 
                     value = c("darkslategray")) %>% 
                 set("labels_cex", 0.5), 
               theme = theme_minimal(),
               horiz = TRUE)
          
ggd1 <- ggd1 + theme(panel.grid.major = element_blank(),
                     axis.text = element_blank(),
                     axis.title = element_blank())
ggd1 <- ggd1 + ylim(max(get_branches_heights(dend)), -1)
ggd1

ggsave('alb_dendro_vertlabs.pdf', plot=ggd1, width=5, height=20, dpi=300)

#With labels removed!!!

alb.dendro.vert <- ggplot(alb.ggd1, horiz = TRUE, labels = FALSE) + 
  scale_y_reverse(expand = c(0.2, 0)) #+
  #coord_polar(theta="x")
alb.dendro.vert 

#Export as .png
ggsave('alb_dendro_vert2.png', plot=alb.dendro.vert, width=5, height=12, dpi=300)

```

### Albacore Cluster Heatmap ----

```{r Extract cluster number to trait matrix}

# Time for the heatmap
# the 1st step here is to have 1 variable per row
# factors have to be converted to characters in order not to be dropped
alb.clust.num <- cutree(alb.aggl.clustc, k = 10)

#we want to bind the original dataset with the cluster numbers such that each species is assigned a cluster
#can use whole data or just traits use to just look at unique species clusters in relation to traits
#alb.cl <- cbind(ctraitsO, alb.clust.num)
#OR
alb.prey.cl <- cbind(spe_traitsO, alb.clust.num)
View(alb.prey.cl)
str(alb.prey.cl)

```

```{r Cluster heatmap}

#Note plyr can mess with this!!
detach("package:plyr", unload=TRUE)

#Create dfs for graphs
alb.clust.long = alb.prey.cl %>%
  dplyr::select(prey_sp, vert_habitat:alb.clust.num) %>%
  dplyr::rename(`vertical habitat` = `vert_habitat`, 
                `horizontal habitat` = `horz_habitat`,
                `diel migrant` = `diel_migrant_cat`, 
                `refuge use` = `refuge_cat`,
                `seasonal migrant` = `season_cat`, 
                `body shape` = `body_shape`,
                `physical defense` = `defense_cat`,
                `gregariousness` = `gregarious_primary`) %>%
  reshape2::melt(id.vars = c("prey_sp", "alb.clust.num"), variable.name = "trait", value.name = "level") %>%
  group_by(alb.clust.num, trait, level) %>%
  mutate(count = n_distinct(prey_sp)) %>%
  distinct(alb.clust.num, trait, level, count) %>% #, percent
  group_by(alb.clust.num, trait) %>%
  mutate(percent = count / sum(count)*100) %>%
  arrange(alb.clust.num)

str(alb.clust.long)

#heatmap.c will be suitable in case you want to go for absolute counts - but it doesn't tell much to my taste
#problem below involves the values of our data being ordinal, therefore they are not unique
levels(alb.clust.long$trait)

#Our data above comes truncated, you would need to truncate the data and re-label clusters depending on which dfs you melt/merge/reshape.
#Example: View(alb.cust.long.q[96:nrow(alb.cust.long.q),])
heatmap.c <- ggplot(alb.clust.long, aes(x = factor(alb.clust.num), y = level)) +
  geom_tile(aes(fill = count))+
  labs(title = "Distribution of characteristics across clusters", x = "Cluster number", y = NULL) +
  scale_fill_viridis(option="magma", begin = 0.2, end = 0.95)+
  facet_grid(trait~. , scales="free_y")
heatmap.c

ggsave('alb_dendro_heatcounts.pdf', plot=heatmap.c, width=8, height=12, dpi=300)


heatmap.p <- ggplot(alb.clust.long, aes(x = factor(alb.clust.num), y = factor(level, ordered = T))) +
  geom_tile(aes(fill = percent), alpha = 0.85)+
  labs(title = "Distribution of characteristics across clusters", x = "Cluster number", y = NULL) +
  #scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4") +
  scale_fill_viridis(option="magma", begin = 0.2, end = 0.95)+
  facet_grid(trait~., scales="free_y")
heatmap.p

ggsave('alb_dendro_heatpercent.pdf', plot=heatmap.p, width=8, height=12, dpi=300)

```


## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
