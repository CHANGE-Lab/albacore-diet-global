---
title: "Albacore Diet Synthesis B"
author: "Natasha Hardy"
date: "15/04/2021"
output: html_document
---

# Prey typologies identified in the diets of albacore tuna

## Workspace

```{r setup, include=FALSE, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```


```{r Worspace}

#Workspace setup
getwd()

#The code used Friday 8th Nov mainly involved the vegan and klaR packages. So you should only need
#to load those out of the list below.

#install what needs to be installed
#install.packages("fpc")
#install.packages("labdsv")
#install.packages("MVPARTwrap") #notice that this didn't work
#library(devtools)
#install_github('kassambara/factoextra')
#install.packages("ggdendro")
#install.packages("circlize")

#some packages are on GitHub and not on the CRAN project yet
#install.packages("devtools") 
#library(devtools)
#install_github("cran/mvpart")
#install_github("cran/MVPARTwrap")
#devtools::install_github("jakelawlor/PNWColors") 

#load all packages required
#library(klaR)
#library(fpc)
#library(ggrepel)
#library(purrr)
#library(viridis)

#library(factoextra)
#library(ggdendro)
#library(circlize)

#Need packages
library(plyr)
library(dplyr)
library(tidyverse)
library(reshape2)
library(here)
"%notin%" = Negate('%in%')
here::here()

# Graphics
library(ggplot2)
library("PNWColors")
library(viridis)

#Multivariate work
library(vegan)
library(cluster)
library("dendextend")

```

## PROBABLE prey traits load & cluster algorithms

### Prey & traits for cluster ----


```{r Load & manip data for cluster analyses}

prey_probable_load = read.csv(here("data/output_data/prey_probable_traits.csv"), header=TRUE) %>%
  dplyr::select(-c(X, diel_migrant, refuge, season_migrant, l_max, trophic_level:standard_total, energy_density:percent_lipid)) %>% 
  dplyr::rename(gregarious = gregarious_primary) %>%
  mutate(diel_migrant_cat = case_when(diel_migrant_cat == "diel_no" ~ "diel (no)",
                                      diel_migrant_cat == "diel_UN" ~ "diel (unknown)",
                                      diel_migrant_cat == "diel_yes" ~ "diel (yes)"),
         refuge_cat = case_when(refuge_cat == "refuge_no" ~ "refuge (no)",
                                refuge_cat == "refuge_NA" ~ "refuge (unknown)",
                                refuge_cat == "refuge_yes" ~ "refuge (yes)"),
         `gregarious`=case_when(`gregarious` == "solitary" ~ "solitary",
                                `gregarious` == "pairing" ~ "solitary",
                                `gregarious` == "shoaling" ~ "schooling",
                                `gregarious` == "schooling" ~ "schooling"),
         season_cat = case_when(season_cat == "season_no" ~ "season (no)",
                                season_cat == "season_NA" ~ "season (unknown)",
                                season_cat == "season_yes" ~ "season (yes)")
         ) 

prey_probable = prey_probable_load %>%
  filter(diel_migrant_cat != "diel (unknown)", 
         refuge_cat != "refuge (unknown)", 
         season_cat != "season (unknown)"
         ) %>%
  drop_na() 
#reduced from ~298 taxa to ~156

levels(as.factor(prey_probable$gregarious))

str(prey_probable)
#148 taxa and 11 variables

```

```{r Data manip for cluster analyses & dendrogram}

## Row name as column datasets
#For probable prey traits
prey_probable_row <- prey_probable
dendlabs <- rownames(prey_probable_row)
prey_probable <- cbind(dendlabs, prey_probable_row)

#Probable trait df subsets
probable_species = prey_probable$prey_sp
prey_probable[,6:17] = lapply(prey_probable[,6:17] , as.factor)
probable_traits = as.data.frame(prey_probable[,c(6:10,11)]) #12

str(probable_traits)
```

### Cluster techniques ----

```{r Cluster & Dissimilarity Matrix}

#### Distance measure ----
#select just the traits you want to contribute to ordination
prob.gower.dist <- daisy(probable_traits, metric = c("gower"))

#### Divisive cluster ----
prob.divisive.clust <- diana(as.matrix(prob.gower.dist), 
                              diss = TRUE, keep.diss = TRUE)
plot(prob.divisive.clust, main = "Divisive")

#### Agglomerative cluster ----
#Use "average" or "complete" linkage
#ADD NOTE ON AVE VS. COMPLETE LINKAGE
prob.aggl.clustc <- hclust(prob.gower.dist, method = "complete")
plot(prob.aggl.clustc, main = "Agglomerative, complete linkages")

#### nMDS for dissimilarity
trait_NMDS_prob <- metaMDS(prob.gower.dist, trymax = 100)
trait_NMDS_prob[["stress"]] #stress = 0.1411261

#Plot --> 
plot(trait_NMDS_prob) #plots species as black dots, traits as red crosses 
###Why are species scores not available?

#Note that the ordination looks good!
#Need to revisit this and plot in relation to clusters!

```

### Cluster Assessment Output

**Notes**
20-24/07/2020
Ultimately we are aiming for distinct clusters of species, such that the difference within clusters is minimal and between clusters is maximised. Assessing cluster statistical tables, we are consistently observing lower average.within cluster differences using agglomerative clustering compared to divisive algorithms. Additionally, cluster sizes and balance are consistently more even using agglomerative vs. divisive.

Using habitat use + gregarious (binary) traits, selecting:
(i) Divisive DONT USE
(ii) Agglomerative (complete) #8 clusters (based on balanced clusters +optimal avg.silwidth value)

Using all traits (habitat use, gregarious, body shape and physical defenses)
(i) Divisive - DO NOT USE
(ii) Agglomerative - 10-11 clusters (based on balanced clusters + optimal avg.silwidth value)

```{r Cluster stat table function}

# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive 
library(fpc)
cstats.table <- function(dist, tree, k) {
  clust.assess <- c("cluster.number","n","within.cluster.ss","average.within","average.between",
                    "wb.ratio","dunn2","avg.silwidth")
  clust.size <- c("cluster.size")
  stats.names <- c()
  row.clust <- c()
  output.stats <- matrix(ncol = k, nrow = length(clust.assess))
  cluster.sizes <- matrix(ncol = k, nrow = k)
  for(i in c(1:k)){
    row.clust[i] <- paste("Cluster-", i, " size")
  }
  for(i in c(2:k)){
    stats.names[i] <- paste("Test", i-1)
    
    for(j in seq_along(clust.assess)){
      output.stats[j, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]
      
    }
    
    for(d in 1:k) {
      cluster.sizes[d, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]
      dim(cluster.sizes[d, i]) <- c(length(cluster.sizes[i]), 1)
      cluster.sizes[d, i]
      
    }
  }
  output.stats.df <- data.frame(output.stats)
  cluster.sizes <- data.frame(cluster.sizes)
  cluster.sizes[is.na(cluster.sizes)] <- 0
  rows.all <- c(clust.assess, row.clust)
  # rownames(output.stats.df) <- clust.assess
  output <- rbind(output.stats.df, cluster.sizes)[ ,-1]
  colnames(output) <- stats.names[2:k]
  rownames(output) <- rows.all
  is.num <- sapply(output, is.numeric)
  output[is.num] <- lapply(output[is.num], round, 2)
  output
}

```

```{r Cluster Assessment Tables}

#Stats table for divisive method
prob.stats.df.divisive <- cstats.table(prob.gower.dist, prob.divisive.clust, 15)
prob.stats.df.divisive

#Stats table for agglomerative method
prob.stats.df.aggl <- cstats.table(prob.gower.dist, prob.aggl.clustc, 15) 
#complete linkages looks like the most balanced approach
prob.stats.df.aggl
write.csv(prob.stats.df.aggl, here("outputs_figures/clusters/prob.stats.df.aggl.csv"))
#As per text for adult, average within cluster metric is minimised for ~7-10 clusters, and the average between for about the same. The agglomerative clustering appears more balanced.

```

**Note** For visualising cluster number selection.

* Elbow method (24/07/2020) using habitat use + gregarious (binary) inflection at 8

* Silhouette (24/07/2020) using habitat use + gregarious (binary) inflection at 8

```{r Cluster Selection - Agglomerative}

### Using "Elbow" and "Silhouette" methods to identify the best number of clusters

# Elbow method

# Agglomerative clustering,provides a more ambiguous picture
ggplot(data = data.frame(t(cstats.table(prob.gower.dist, prob.aggl.clustc, 20))), 
       aes(x=cluster.number, y=within.cluster.ss)) + 
  geom_point()+
  geom_line()+
  ggtitle("Agglomerative clustering") +
  labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
  theme(plot.title = element_text(hjust = 0.5))

## Silhouette
#When it comes to silhouette assessment, the rule is you should choose the number that maximizes the 
#silhouette coefficient because you want clusters that are distinctive (far) enough to be considered separate.

# Agglomerative
ggplot(data = data.frame(t(cstats.table(prob.gower.dist, prob.aggl.clustc, 20))), 
       aes(x=cluster.number, y=avg.silwidth)) + 
  geom_point()+
  geom_line()+
  ggtitle("Agglomerative clustering") +
  labs(x = "Num.of clusters", y = "Average silhouette width") +
  theme(plot.title = element_text(hjust = 0.5))

```

## PROBABLE Agglomerative (complete) k = 8

### Cluster Dendrograms ---

Going to use k = 8 for the probable life stage traits

**Horizontal dendrogram**

```{r Horizontal dendrogram}

#Using agglomerative hierarchical clustering, k = 8
prob.dendro <- as.dendrogram(prob.aggl.clustc) #148 species
PNW.pal8 <- pnw_palette(8, name = "Bay", type = "continuous")
###Horizontal dendrogram - Probable traits

#Horizontal cluster illustration version
prob.dendro.col <- prob.dendro %>%
  set("branches_k_color", k = 8, value = PNW.pal8) %>%
  set("branches_lwd", 0.8) %>%
  set("labels", probable_species) %>% #NOT VERY LEGIBLE...
  set("labels_colors", 
      value = c("darkslategray")) %>% 
  set("labels_cex", 0.5)
prob.ggd1 <- as.ggdend(prob.dendro.col)
prob.dendro.graph <- ggplot(prob.ggd1, theme = theme_minimal()) +
  labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 8")
prob.dendro.graph

ggsave(here('outputs_figures/clusters/prob.dendro.horz.k8.png'), plot=prob.dendro.graph, width=8, height=8, dpi=300)

```

**Radial dendrogram**

```{r Radial dendrogram}

# Radial plot looks less cluttered (and cooler)
prob.dendro.rad <- ggplot(prob.ggd1, labels = FALSE) + 
  scale_y_reverse(expand = c(0.2, 0)) +
  coord_polar(theta="x")
prob.dendro.rad 
#No labels on this one, labels were too cluttered/problems
#Save radial dendrogram for chat

ggsave(here('outputs_figures/clusters/prob.dendro.rad.k8.png'), plot=prob.dendro.rad, width=8, height=8, dpi=300)

```

**Vertical dendrogram**

Similar to https://stackoverflow.com/questions/38034663/rotate-labels-for-ggplot-dendrogram 

```{r Vertical dendrogram}

# This is a different way to compute hierarchical clustering and cut the tree
#clus <- hcut(mydist, k = 6, hc_func = 'hclust', hc_method = 'ward.D2', graph = FALSE, isdiss = TRUE)

#Below is problematic0
#labels(dend) <- paste0(paste0(rep('', 3), collapse = ''), speciesO)
#dend <- sort(dend, decreasing = FALSE)
#View(labels(dend))

#Creating df for the dend labels so that we can accurately line them up with the species
dendlabs <- labels(prob.dendro) #Need to create strings of labels to manipulate
dendlabs2 <- as.data.frame(dendlabs) #turn in df

#Join these data so we can relabel the dendrogram
#Use plyr function because it conserves the row order of the left df, which matters for assigning labels here
dfdend <- join(dendlabs2, prey_probable)

ggd1 <- ggplot(prob.dendro %>%
                 set("branches_k_color", k = 8, value = PNW.pal8) %>%
                 set("branches_lwd", 0.8) %>%
                 set("labels", dfdend$prey_sp) %>% #NOT VERY LEGIBLE...
                 set("labels_colors", 
                     value = c("darkslategray")) %>% 
                 set("labels_cex", 0.5), 
               theme = theme_minimal(),
               horiz = TRUE)

ggd1 <- ggd1 + theme(panel.grid.major = element_blank(),
                     axis.text = element_blank(),
                     axis.title = element_blank())
ggd1 <- ggd1 + ylim(max(get_branches_heights(prob.dendro)), -1)
ggd1

ggsave(here('outputs_figures/clusters/prob.dendro.vertlabs.k8.pdf'), plot=ggd1, width=5, height=20, dpi=300)

#With labels removed!!!

prob.dendro.vert <- ggplot(prob.ggd1, horiz = TRUE, labels = FALSE) + 
  scale_y_reverse(expand = c(0.2, 0)) #+
#coord_polar(theta="x")
prob.dendro.vert 
#Export as .png
ggsave(here('outputs_figures/clusters/prob.dendro.vert2.k8.png'), plot=prob.dendro.vert, width=5, height=12, dpi=300)


```


**Vertical dendro with traits**

The rows are ordered based on the order of the hierarchical clustering (using the “complete” method). The colored bar indicates the species category each row belongs to. The color in the heatmap indicates the length of each measurement (from light yellow to dark red).

In the heatmap we also see how the Setosa species has low petal values (in light yellow), but it is very difficult to see any clear distinction between the other two species.
         
```{r Vertical dendro with traits, eval=FALSE}
some_col_func <- function(n) rev(colorspace::heat_hcl(n, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5)))

# scaled_iris2 <- iris2 %>% as.matrix %>% scale
# library(gplots)
gplots::heatmap.2(as.matrix(prob.aggl.clustc), 
          main = "Heatmap for the Iris data set",
          srtCol = 20,
          dendrogram = "row",
          Rowv = prob.dendro,
          Colv = "NA", # this to make sure the columns are not ordered
          trace="none",          
          margins =c(5,0.1),      
          key.xlab = "Cm",
          denscol = "grey",
          density.info = "density",
          RowSideColors = rev(labels_colors(prob.dendro)), # to add nice colored strips        
          col = some_col_func
         )
```


### Albacore Cluster Heatmap ----

```{r Extract cluster number to trait matrix}

#Extract cluster number to trait matrix
prob.clust.num <- cutree(prob.aggl.clustc, k = 8)

#we want to bind the original dataset with the cluster numbers such that each species is assigned a cluster
#can use whole data or just traits use to just look at unique species clusters in relation to traits
#alb.cl <- cbind(ctraitsO, alb.clust.num)
#OR
prob.prey.cl <- cbind(prey_probable, prob.clust.num)

#View(prob.prey.cl)

write.csv(prob.prey.cl, here("data/output_data/prob.prey.clusternum_habgreg.aggl.k8.csv"))
write.csv(prob.prey.cl, here("outputs_figures/clusters/prob.prey.clusternum_habgreg.aggl.k8.csv"))

```

```{r Cluster heatmap}
# Time for the heatmap
# the 1st step here is to have 1 variable per row
# factors have to be converted to characters in order not to be dropped

#Note plyr can mess with this!!
detach("package:plyr", unload=TRUE)

#Create dfs for graphs
prob.clust.long = prob.prey.cl %>%
  dplyr::select(prey_sp, vert_habitat:season_cat, `gregarious`, `prob.clust.num`) %>% #maxFO:maxM, 
  reshape2::melt(id.vars = c("prey_sp", "prob.clust.num"), variable.name = "trait", value.name = "level") %>%
  group_by(prob.clust.num, trait, level) %>%
  mutate(count = n_distinct(prey_sp)) %>%
  distinct(prob.clust.num, trait, level, count) %>% #, percent
  group_by(prob.clust.num, trait) %>%
  mutate(percent = count / sum(count)*100) %>%
  arrange(prob.clust.num)

str(prob.clust.long)

#heatmap.c will be suitable in case you want to go for absolute counts - but it doesn't tell much to my taste
#problem below involves the values of our data being ordinal, therefore they are not unique
levels(prob.clust.long$trait)

#Our data above comes truncated, you would need to truncate the data and re-label clusters depending on which dfs you melt/merge/reshape.
#Example: View(alb.cust.long.q[96:nrow(alb.cust.long.q),])
heatmap.c <- ggplot(prob.clust.long, aes(x = factor(prob.clust.num), y = level)) +
  geom_tile(aes(fill = count))+
  labs(title = "Distribution of characteristics across clusters", x = "Cluster number", y = NULL) +
  scale_fill_viridis(option="magma", begin = 0.2, end = 0.95)+
  facet_grid(trait~. , scales="free_y")
heatmap.c

ggsave(here('outputs_figures/clusters/prob.dendro.heatcounts.k8.pdf'), plot=heatmap.c, width=8, height=12, dpi=300)


heatmap.p <- ggplot(prob.clust.long, aes(x = factor(prob.clust.num), y = factor(level, ordered = T))) +
  geom_tile(aes(fill = percent), alpha = 0.85)+
  labs(title = "Distribution of characteristics across clusters", x = "Cluster number", y = NULL) +
  #scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4") +
  scale_fill_viridis(option="magma", begin = 0.2, end = 0.95)+
  facet_grid(trait~., scales="free_y")
heatmap.p

ggsave(here('outputs_figures/clusters/prob.dendro.heatpercent.aggl.k8.pdf'), plot=heatmap.p, width=8, height=12, dpi=300)

```


## NMDS for checking on our ordination

### Ordination

```{r NMDS & Clusters ~ Species}
#### nMDS for dissimilarity
trait_NMDS_prob <- metaMDS(prob.gower.dist, trymax = 1000) #solution a 20 iterations
trait_NMDS_prob[["stress"]] #stress = 0.14 #reasonable

#Simple Plot --> 
#plot(trait_NMDS) #plots species as black dots, traits as red crosses 
#Note that the ordination looks good!
#Need to revisit this and plot in relation to clusters!

```

### Extract NMDS coordinates and associate with co-variates/grouping factors

```{r Data scores for plotting - USE}

#Extract NMDS coordinates and associate with co-variates/grouping factors

#Using the scores function from vegan to extract the site scores and convert to a data.frame
data.scores <- as.data.frame(scores(trait_NMDS_prob))  #, "species"

#create a column of site names, from the rownames of data.scores
data.scores$points <- rownames(data.scores)

#bind treatment labels and score values
treatment.scores <- cbind(prob.prey.cl, data.scores)

#Check
str(treatment.scores)  
#Awesome

```

### Convex hull calculations
For each ordination and set of grouping variables input to data scores chunk


```{r Convex hulls - Taxonomic specific}
# Taxonomic groups (specific)
#Create convex hulls for the space occupied by each Taxonomic values
unique(treatment.scores$prob.clust.num)
length(treatment.scores$prob.clust.num) #174

#Taxonomic group - hull loop
clust = as.character(unique(treatment.scores$prob.clust.num))
for(i in 1:length(clust)) {
  temp = clust[i]
  df = treatment.scores[treatment.scores$prob.clust.num == temp, ][chull(treatment.scores[treatment.scores$prob.clust.num == temp, c("NMDS1", "NMDS2")]), ]
  assign(paste0('grp.',temp), df)
}

#combine the hull data
hull.data <- rbind(grp.1, grp.2, grp.3, grp.4, grp.5, grp.6, grp.7, grp.8)  

str(hull.data)
#Just wondering how do 174 species (obs) become 46???

```


### NMDS plot

```{r nMDS Cluster #, echo=TRUE}
#nMDS plot for the assessmenet of global change (yes/no) and the drivers.
#as.integer(unique(treatment.scores$adult.clust.num))

trait_nMDS_prob_fig <- ggplot() + 
  geom_polygon(data=hull.data, 
               aes(x=NMDS1, y=NMDS2, 
                   fill= prob.clust.num, 
                   group= prob.clust.num), 
               alpha=0.30) + # add the convex hulls
  geom_point(data=treatment.scores, 
             aes(x=NMDS1, y=NMDS2, colour= prob.clust.num), 
             size=2) + # add the point markers
  coord_equal() +
  theme_bw()  +
  theme(axis.text.x = element_blank(),  # remove x-axis text
        axis.text.y = element_blank(), # remove y-axis text
        axis.ticks = element_blank(),  # remove axis ticks
        axis.title.x = element_text(size=18), # remove x-axis labels
        axis.title.y = element_text(size=18), # remove y-axis labels
        legend.title = element_text(size = 18), 
        legend.text = element_text(size = 18),
        legend.justification = c(0,0.5),
        #panel.background = element_rect(fill = "lightgrey"), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank()) +
  #guides(fill = FALSE, colour = FALSE) +
  #guides(fill = guide_legend(order = 1), colour = guide_legend(order = 2)) +
  scale_colour_viridis(option="magma", begin = 0.8, end = 0.2, name = "Cluster Number") + 
  scale_fill_viridis(option="magma", begin = 0.8, end = 0.2, name = "Cluster Number") #+
  
trait_nMDS_prob_fig
##Not perfect, some issues to troubleshoot

ggsave(here("outputs_figures/clusters/trait_nMDS_prob_clusters.png"), 
       plot = trait_nMDS_prob_fig, width = 8, height = 8, dpi = 300)

```

```{r nMDS Cluster + FO}

trait_nMDS_prob_fo <- ggplot() + 
  geom_polygon(data=hull.data, 
               aes(x=NMDS1, y=NMDS2, 
                   fill= prob.clust.num, 
                   group= prob.clust.num), 
               alpha=0.30) + # add the convex hulls
  geom_point(data=treatment.scores, 
             aes(x=NMDS1, y=NMDS2, colour= maxFO), 
             size=2) + # add the point markers
  coord_equal() +
  theme_bw()  +
  theme(axis.text.x = element_blank(),  # remove x-axis text
        axis.text.y = element_blank(), # remove y-axis text
        axis.ticks = element_blank(),  # remove axis ticks
        axis.title.x = element_text(size=18), # remove x-axis labels
        axis.title.y = element_text(size=18), # remove y-axis labels
        legend.title = element_text(size = 18), 
        legend.text = element_text(size = 18),
        legend.justification = c(0,0.5),
        #panel.background = element_rect(fill = "lightgrey"), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank()) +
  #guides(fill = FALSE, colour = FALSE) +
  #guides(fill = guide_legend(order = 1), colour = guide_legend(order = 2)) +
  scale_colour_viridis(option="A", begin = 0.2, end = 0.8, name = "Frequency of Occurrence (%)") + 
  scale_fill_viridis(option="magma", begin = 0.8, end = 0.2, name = "Cluster Number") #+
  
trait_nMDS_prob_fo


ggsave(here("outputs_figures/clusters/trait_nMDS_prob_fo.png"), 
       plot = trait_nMDS_prob_fo, width = 8, height = 8, dpi = 300)

```

```{r nMDS Cluster + %N}

trait_nMDS_prob_no <- ggplot() + 
  geom_polygon(data=hull.data, 
               aes(x=NMDS1, y=NMDS2, 
                   fill= prob.clust.num, 
                   group= prob.clust.num), 
               alpha=0.30) + # add the convex hulls
  geom_point(data=treatment.scores, 
             aes(x=NMDS1, y=NMDS2, colour= maxN), 
             size=2) + # add the point markers
  coord_equal() +
  theme_bw()  +
  theme(axis.text.x = element_blank(),  # remove x-axis text
        axis.text.y = element_blank(), # remove y-axis text
        axis.ticks = element_blank(),  # remove axis ticks
        axis.title.x = element_text(size=18), # remove x-axis labels
        axis.title.y = element_text(size=18), # remove y-axis labels
        legend.title = element_text(size = 18), 
        legend.text = element_text(size = 18),
        legend.justification = c(0,0.5),
        #panel.background = element_rect(fill = "lightgrey"), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank()) +
  #guides(fill = FALSE, colour = FALSE) +
  #guides(fill = guide_legend(order = 1), colour = guide_legend(order = 2)) +
  scale_colour_viridis(option="A", begin = 0.2, end = 0.8, name = "Numerical Abundance (%)") + 
  scale_fill_viridis(option="magma", begin = 0.8, end = 0.2, name = "Cluster Number") #+
  
trait_nMDS_prob_no


#ggsave(here("outputs_figures/clusters/trait_nMDS_prob_fo.png"), 
#       plot = trait_nMDS_prob_fo, width = 8, height = 8, dpi = 300)

```