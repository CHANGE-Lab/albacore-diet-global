---
title: "Albacore Diet Synthesis B"
author: "Natasha Hardy"
date: "15/04/2021"
output:
  html_document: default
  pdf_document: default
---

# Prey typologies identified in the diets of albacore tuna

## About

**Prey typologies text from Ms.** Here, we identified key prey typologies or functional groups in albacore tuna diets using hierarchical clustering calculated with divisive algorithms (Jain et al., 1999; Legendre & Legendre, 1998) on a Gower dissimilarity matrix (Gower, 1971) to identify relational structure between mixed ecological traits types: 3 binomial variables and 2 categorical variables for prey species traits (packages included: cluster, vegan and dendextend; code found under ‘Albacore_synthesis_b.Rmd’). Our objective in clustering selection (Brock et al., 2008; Charrad et al., 2014; Theodoridis & Koutroumbas, 2006) is to optimise the number of clusters based on (1) maximum differentiation or separation of species between clusters, (2) minimum differentiation of species or compactness within clusters, (3) optimal silhouette width coefficient value as well as Dunny Smith residuals, and (4) evenness or balance of cluster composition (number of species in each cluster). We assessed clusters visually for balance and consistency using cluster dendrograms and trait values that influenced a species’ occupancy within a cluster are visualised using heatmaps. The relative position of species to each other in relation to their cluster occupancy, and based on shared or separation of trait values, was visualised using multivariate ordination-based, non-metric multidimensional scaling (nMDS) (Field et al., 1982).

We use code and concepts described by Anastasia Reusova here: https://towardsdatascience.com/hierarchical-clustering-on-categorical-data-in-r-a27e578f2995

And cluster validation concepts further discussed here: https://www.datanovia.com/en/lessons/cluster-validation-statistics-must-know-methods/#silhouette-coefficient


## Workspace

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```


```{r Worspace, results='hide', tidy=TRUE, message=FALSE}

#Need packages
library(plyr)
library(dplyr)
library(tidyverse)
library(reshape2)
library(factoextra)
library(here)
"%notin%" = Negate('%in%')
here::here()

#Markdown
library(formatR)

# Graphics
library(ggplot2)
library("PNWColors")
library(viridis)

#Multivariate work
library(vegan)
library(cluster)
library("dendextend")
library(NbClust)

```

## PROBABLE prey traits load & cluster algorithms

### Prey & traits for cluster

Here we use the cleaned file for prey species traits based on probable life stage consumed by albacore. We need to select species for which we have complete trait information for the selected traits. We obtain 156 taxa with complete trait information for the selected traits noted here.

Below we select variables for use in clustering algorithms. We selected vertical and horizontal habitat association, as well as diel and seasonal migratory traits, the probable life stage consumed and aggregation behaviour. We selected these traits because we hypothesised that these relate to the first level of filtering in the predation process -- encountering prey.

```{r Load and manip data for cluster analyses, tidy=TRUE, warning=FALSE, message=FALSE}

prey_probable_load = read.csv(here("data/output_data/prey_trait_probable_select.csv"), header=TRUE) %>% #prey_probable_traits.csv
  dplyr::select(-c(diel_migrant, refuge, refuge_cat, season_migrant, l_max:fisheries_status)) %>% 
  dplyr::rename(gregarious = gregarious_primary) %>%
  mutate(diel_migrant_cat = case_when(diel_migrant_cat == "diel_no" ~ "diel (no)",
                                      diel_migrant_cat == "diel_UN" ~ "diel (unknown)",
                                      diel_migrant_cat == "diel_yes" ~ "diel (yes)"),
         #refuge_cat = case_when(refuge_cat == "refuge_no" ~ "refuge (no)",
          #                      refuge_cat == "refuge_NA" ~ "refuge (unknown)",
          #                      refuge_cat == "refuge_yes" ~ "refuge (yes)"),
         `gregarious`=case_when(`gregarious` == "solitary" ~ "solitary",
                                `gregarious` == "pairing" ~ "solitary",
                                `gregarious` == "shoaling" ~ "schooling",
                                `gregarious` == "schooling" ~ "schooling"),
         season_cat = case_when(season_cat == "season_no" ~ "season (no)",
                                season_cat == "season_NA" ~ "season (unknown)",
                                season_cat == "season_yes" ~ "season (yes)")
         ) 
#Note that we are grouping shoaling and schooling as traits due to low numbers, as well as solitary and pairing species.

prey_probable = prey_probable_load %>%
  filter(diel_migrant_cat != "diel (unknown)", 
         #refuge_cat != "refuge (unknown)", 
         season_cat != "season (unknown)"
         ) %>%
  drop_na()

prey_probable[,6:11] = lapply(prey_probable[,6:11] , as.factor)

```

**NOTE:** Remaining issues with trait distributions.

Previous clustering analyses showed that bathypelagic and mesopelagic taxa tended to cluster together, as did reef and coastal taxa.
We could merge values are we do later for 4th corner analyses.

Here we check the trait values for each trait, and check the distribution of values. Note we merge certain values with low occurrences of species within them, and if we have a logical reason to merge.

```{r Trait values check, warning=FALSE, message=FALSE}
summary(prey_probable$life_stage) #we will remove larva as a value from the df, larval taxa didn't make it through the data cleaning and manipulation.

summary(prey_probable$vert_habitat) #merge bathypelagic and mesopelagic, these prey could not have been consumed in the bathypelagic anyways.

summary(prey_probable$horz_habitat) #merge of continental shelf/slope, and coastal/reef assoc, we do not have enough data to properly differentiate and represent these habitat values, so we merge and take a coarser definition of 'continental shelf & slope' and 'coastal & reef-assoc'.

summary(prey_probable$diel_migrant_cat) #a lot more diel migrants than not

summary(prey_probable$season_cat) #more seasonal taxa than not

```

```{r Trait df cleaning}

prey_probable = prey_probable %>%
  filter(life_stage != "larva")

#Levels vertical habitat
#levels(alb_prob_traits$vert_habitat) #check
prey_probable$vert_habitat <- factor(prey_probable$vert_habitat, 
                                            levels = c("benthic", "demersal", "epipelagic",
                                                       "mesopelagic", "bathypelagic"),
                                            labels = c("benthic", "demersal", "epipelagic",
                                                       "mesopelagic", "mesopelagic"))
#Too low sample size for bathypelagic, merged with mesopelagic here

#Levels horizontal habitat
#levels(alb_prob_traits$horz_habitat) #check
prey_probable$horz_habitat <- factor(prey_probable$horz_habitat, 
                                            levels = c("reef-associated", "coastal", 
                                                       "continental shelf", "continental slope",
                                                       "oceanic"),
                                            labels = c("coastal", "coastal", 
                                                       "continental shelf", "continental shelf",
                                                       "oceanic"))

```

**Dataframes for analyses:**

```{r Data manip for cluster analyses and dendrogram, tidy=TRUE, warning=FALSE, message=FALSE}

## Row name as column datasets
#For probable prey traits
prey_probable_row <- prey_probable
dendlabs <- rownames(prey_probable_row)
prey_probable <- cbind(dendlabs, prey_probable_row)

#Probable trait df subsets
probable_species = prey_probable$prey_sp
#prey_probable[,6:12] = lapply(prey_probable[,6:12] , as.factor)
probable_traits = as.data.frame(prey_probable[,c(7:12)]) #12

probable_traits = prey_probable %>%
  dplyr::select(life_stage, vert_habitat, horz_habitat, diel_migrant_cat, season_cat) #, gregarious
#Old version didn't include gregarious

str(probable_traits)

summary(probable_traits)
```


### Cluster techniques

Here we generate a multivariate species-based dissimilarity matrix of the data, and both a hierarchical divisive and agglomerative clustering algorithm in order to select the most appropriate algorithm.

```{r Cluster and Dissimilarity Matrix, warning=FALSE, message=FALSE}

#### Distance measure ----
#select just the traits you want to contribute to ordination
prob.gower.dist <- daisy(probable_traits, metric = c("gower"))

#### Divisive cluster ----
prob.divisive.clust <- diana(as.matrix(prob.gower.dist), 
                              diss = TRUE, keep.diss = TRUE)
plot(prob.divisive.clust, main = "Divisive")

#### Agglomerative cluster ----
#Use "average" or "complete" linkage
#ADD NOTE ON AVE VS. COMPLETE LINKAGE
prob.aggl.clustc <- hclust(prob.gower.dist, method = "complete")
plot(prob.aggl.clustc, main = "Agglomerative, complete linkages")

```

```{r Check ordination, warning=FALSE, message=FALSE, results='hide'}

#### nMDS for dissimilarity - checking the dissimilarity matrix
trait_NMDS_prob <- metaMDS(prob.gower.dist, trymax = 100)
trait_NMDS_prob[["stress"]] #stress = 0.1177472

#Plot --> 
plot(trait_NMDS_prob) #plots species as black dots

#Note that the ordination looks good!
#Need to revisit this and plot in relation to clusters!

```

### Cluster Assessment Output

**Notes**
20-24/07/2020

Ultimately we are aiming for distinct clusters of species, such that the difference within clusters is minimal and between clusters is maximised. Assessing cluster statistical tables, we are consistently observing lower average.within cluster differences using agglomerative clustering compared to divisive algorithms.

Below we are using habitat use + gregarious (as binary) traits for:
(i) Divisive
(ii) Agglomerative (complete)

```{r Cluster stat table function, warning=FALSE, message=FALSE}

# Cluster stats comes out as list while it is more convenient to look at it as a table
# This code below will produce a dataframe with observations in columns and variables in row
# Not quite tidy data, which will require a tweak for plotting, but I prefer this view as an output here as I find it more comprehensive 
library(fpc)
cstats.table <- function(dist, tree, k) {
  clust.assess <- c("cluster.number","n","within.cluster.ss","average.within","average.between",
                    "wb.ratio","dunn2","avg.silwidth")
  clust.size <- c("cluster.size")
  stats.names <- c()
  row.clust <- c()
  output.stats <- matrix(ncol = k, nrow = length(clust.assess))
  cluster.sizes <- matrix(ncol = k, nrow = k)
  for(i in c(1:k)){
    row.clust[i] <- paste("Cluster-", i, " size")
  }
  for(i in c(2:k)){
    stats.names[i] <- paste("Test", i-1)
    
    for(j in seq_along(clust.assess)){
      output.stats[j, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j]
      
    }
    
    for(d in 1:k) {
      cluster.sizes[d, i] <- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d]
      dim(cluster.sizes[d, i]) <- c(length(cluster.sizes[i]), 1)
      cluster.sizes[d, i]
      
    }
  }
  output.stats.df <- data.frame(output.stats)
  cluster.sizes <- data.frame(cluster.sizes)
  cluster.sizes[is.na(cluster.sizes)] <- 0
  rows.all <- c(clust.assess, row.clust)
  # rownames(output.stats.df) <- clust.assess
  output <- rbind(output.stats.df, cluster.sizes)[ ,-1]
  colnames(output) <- stats.names[2:k]
  rownames(output) <- rows.all
  is.num <- sapply(output, is.numeric)
  output[is.num] <- lapply(output[is.num], round, 2)
  output
}

```

In the output below, we assess primarily: 

(i) Balance between and within clusters == the number of species per cluster and between cluster. We are looking for the method which provides the greatest balance.

(ii) Balance of the lowest 'average.within' and greatest 'average.between' differences between clusters.

(iii) Lower 'dunn2' or dunny smith residual values.

(iv) Higher 'avg.sildwidth' or average silhouette width values.

**NOTE: We observe the greatest balance between these cluster validation criteria for the hierarchical divisive clustering algorithm and for k = 7 clusters.**

```{r Cluster Assessment Tables, warning=FALSE, message=FALSE}

#Stats table for divisive method
prob.stats.df.divisive <- cstats.table(prob.gower.dist, prob.divisive.clust, 15)
prob.stats.df.divisive
View(prob.stats.df.divisive)
write.csv(prob.stats.df.divisive, here("outputs_figures/clusters/prob_cluster_sep2021_simple/prob.stats.df.divisive.csv"))

#Stats table for agglomerative method
prob.stats.df.aggl <- cstats.table(prob.gower.dist, prob.aggl.clustc, 15) 
#complete linkages looks like the most balanced approach
prob.stats.df.aggl
View(prob.stats.df.aggl)
write.csv(prob.stats.df.aggl, here("outputs_figures/clusters/prob_cluster_sep2021_simple/prob.stats.df.aggl.csv"))
#As per text for adult, average within cluster metric is minimised for ~7-10 clusters, and the average between for about the same. The agglomerative clustering appears more balanced.

```

**Note** Agglomerative -- for visualising cluster number selection.

Currently not using the agglomerative output based on stats table output.

```{r Cluster Selection - Agglomerative, warning=FALSE, message=FALSE}

### Using "Elbow" and "Silhouette" methods to identify the best number of clusters

# Elbow method

# Agglomerative clustering,provides a more ambiguous picture
ggplot(data = data.frame(t(cstats.table(prob.gower.dist, prob.aggl.clustc, 20))), 
       aes(x=cluster.number, y=within.cluster.ss)) + 
  geom_point()+
  geom_line()+
  ggtitle("Agglomerative clustering") +
  labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
  theme(plot.title = element_text(hjust = 0.5))

## Silhouette
#When it comes to silhouette assessment, the rule is you should choose the number that maximizes the 
#silhouette coefficient because you want clusters that are distinctive (far) enough to be considered separate.

# Agglomerative
ggplot(data = data.frame(t(cstats.table(prob.gower.dist, prob.aggl.clustc, 20))), 
       aes(x=cluster.number, y=avg.silwidth)) + 
  geom_point()+
  geom_line()+
  ggtitle("Agglomerative clustering") +
  labs(x = "Num.of clusters", y = "Average silhouette width") +
  theme(plot.title = element_text(hjust = 0.5))

```

**Note** Divisive -- for visualising cluster number selection.

* Elbow method (20/03/2021) using habitat use + gregarious (binary) + life stage without refuge use inflection at 7

* Silhouette (20/03/2021) using habitat use + gregarious (binary) + life stage without refuge use inflection at 7

```{r Cluster Selection - Divisive, warning=FALSE, message=FALSE}

### Using "Elbow" and "Silhouette" methods to identify the best number of clusters

# Elbow method

ggplot(data = data.frame(t(cstats.table(prob.gower.dist, prob.divisive.clust, 20))), 
       aes(x=cluster.number, y=within.cluster.ss)) + 
  geom_point()+
  geom_line()+
  ggtitle("Divisive clustering") +
  labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") +
  theme(plot.title = element_text(hjust = 0.5))

## Silhouette
#When it comes to silhouette assessment, the rule is you should choose the number that maximizes the 
#silhouette coefficient because you want clusters that are distinctive (far) enough to be considered separate.

# Agglomerative
ggplot(data = data.frame(t(cstats.table(prob.gower.dist, prob.divisive.clust, 20))), 
       aes(x=cluster.number, y=avg.silwidth)) + 
  geom_point()+
  geom_line()+
  ggtitle("Divisive clustering") +
  labs(x = "Num.of clusters", y = "Average silhouette width") +
  theme(plot.title = element_text(hjust = 0.5))

```

## PROBABLE Agglomerative k = 7
### Cluster Dendrograms

Using k = 7 for the habitat association, aggregation behaviour & probable life stage traits.

**Horizontal dendrogram**

```{r Horizontal dendrogram, warning=FALSE, message=FALSE}

#Using agglomerative hierarchical clustering, k = 8
prob.dendro <- as.dendrogram(prob.aggl.clustc) #156 species
PNW.pal7 <- pnw_palette(7, name = "Bay", type = "continuous")
###Horizontal dendrogram - Probable traits

#Horizontal cluster illustration version
prob.dendro.col <- prob.dendro %>%
  set("branches_k_color", k = 7, value = PNW.pal7) %>%
  set("branches_lwd", 0.8) %>%
  set("labels", probable_species) %>% #NOT VERY LEGIBLE...
  set("labels_colors", 
      value = c("darkslategray")) %>% 
  set("labels_cex", 0.5)
prob.ggd1 <- as.ggdend(prob.dendro.col)
prob.dendro.graph <- ggplot(prob.ggd1, theme = theme_minimal()) +
  labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 6")
prob.dendro.graph

ggsave(here('outputs_figures/clusters/prob_cluster_sep2021_simple/prob.dendro.horz.k7.png'), plot=prob.dendro.graph, width=8, height=8, dpi=300)

```

**Radial dendrogram**

```{r Radial dendrogram, warning=FALSE, message=FALSE}

# Radial plot looks less cluttered (and cooler)
prob.dendro.rad <- ggplot(prob.ggd1, labels = FALSE) + 
  scale_y_reverse(expand = c(0.2, 0)) +
  coord_polar(theta="x")
prob.dendro.rad 
#No labels on this one, labels were too cluttered/problems
#Save radial dendrogram for chat

ggsave(here('outputs_figures/clusters/prob_cluster_sep2021_simple/prob.dendro.rad.k7.png'), plot=prob.dendro.rad, width=8, height=8, dpi=300)

```

**Vertical dendrogram**

Similar to https://stackoverflow.com/questions/38034663/rotate-labels-for-ggplot-dendrogram 

```{r Vertical dendrogram, warning=FALSE, message=FALSE}

# This is a different way to compute hierarchical clustering and cut the tree
#clus <- hcut(mydist, k = 6, hc_func = 'hclust', hc_method = 'ward.D2', graph = FALSE, isdiss = TRUE)

#Below is problematic0
#labels(dend) <- paste0(paste0(rep('', 3), collapse = ''), speciesO)
#dend <- sort(dend, decreasing = FALSE)
#View(labels(dend))

#Creating df for the dend labels so that we can accurately line them up with the species
dendlabs <- labels(prob.dendro) #Need to create strings of labels to manipulate
dendlabs2 <- as.data.frame(dendlabs) #turn in df

#Join these data so we can relabel the dendrogram
#Use plyr function because it conserves the row order of the left df, which matters for assigning labels here

dfdend <- join(dendlabs2, prey_probable)

ggd1 <- ggplot(prob.dendro %>%
                 set("branches_k_color", k = 7, value = PNW.pal7) %>%
                 set("branches_lwd", 0.8) %>%
                 set("labels", dfdend$prey_sp) %>% #NOT VERY LEGIBLE...
                 set("labels_colors", 
                     value = c("darkslategray")) %>% 
                 set("labels_cex", 0.5), 
               theme = theme_minimal(),
               horiz = TRUE)

ggd1 <- ggd1 + theme(panel.grid.major = element_blank(),
                     axis.text = element_blank(),
                     axis.title = element_blank())
ggd1 <- ggd1 + ylim(max(get_branches_heights(prob.dendro)), -1)
ggd1

ggsave(here('outputs_figures/clusters/prob_cluster_sep2021_simple/prob.dendro.vertlabs.k7.pdf'), plot=ggd1, width=5, height=20, dpi=300)

#With labels removed!!!

prob.dendro.vert <- ggplot(prob.ggd1, horiz = TRUE, labels = FALSE) + 
  scale_y_reverse(expand = c(0.2, 0)) #+
#coord_polar(theta="x")
prob.dendro.vert 
#Export as .png
ggsave(here('outputs_figures/clusters/prob_cluster_sep2021_simple/prob.dendro.vert2.k7.png'), plot=prob.dendro.vert, width=5, height=12, dpi=300)


```


### Cluster Heatmaps 

```{r Extract cluster number to trait matrix, warning=FALSE, message=FALSE}

#Extract cluster number to trait matrix
prob.clust.num <- cutree(prob.aggl.clustc, k = 7)

#we want to bind the original dataset with the cluster numbers such that each species is assigned a cluster
#can use whole data or just traits use to just look at unique species clusters in relation to traits
#alb.cl <- cbind(ctraitsO, alb.clust.num)
#OR
prob.prey.cl <- cbind(prey_probable, prob.clust.num)

#View(prob.prey.cl)

##NOTE TO CHANGE THIS TO ADD DATA TO OUTPUT
#write.csv(prob.prey.cl, here("data/output_data/prob.prey.clusternum_habgreg.divis.k8.csv"))
write.csv(prob.prey.cl, here("outputs_figures/clusters/prob_cluster_sep2021_simple/prob.prey.clusternum_aggl.k7.csv"), row.names = FALSE)

```

```{r Cluster heatmap, warning=FALSE, message=FALSE}
# Time for the heatmap
# the 1st step here is to have 1 variable per row
# factors have to be converted to characters in order not to be dropped

#Note plyr can mess with this!!
#detach("package:plyr", unload=TRUE)

#Create dfs for graphs
prob.clust.long = prob.prey.cl %>%
  dplyr::select(prey_sp, life_stage:season_cat, `gregarious`, `prob.clust.num`) %>% #maxFO:maxM, 
  reshape2::melt(id.vars = c("prey_sp", "prob.clust.num"), variable.name = "trait", value.name = "level") %>%
  group_by(prob.clust.num, trait, level) %>%
  mutate(count = n_distinct(prey_sp)) %>%
  distinct(prob.clust.num, trait, level, count) %>% #, percent
  group_by(prob.clust.num, trait) %>%
  mutate(percent = count / sum(count)*100) %>%
  arrange(prob.clust.num)

#str(prob.clust.long)

#heatmap.c will be suitable in case you want to go for absolute counts - but it doesn't tell much to my taste
#problem below involves the values of our data being ordinal, therefore they are not unique
levels(prob.clust.long$trait)

#Our data above comes truncated, you would need to truncate the data and re-label clusters depending on which dfs you melt/merge/reshape.
#Example: View(alb.cust.long.q[96:nrow(alb.cust.long.q),])
heatmap.c <- ggplot(prob.clust.long, aes(x = factor(prob.clust.num), y = level)) +
  geom_tile(aes(fill = count))+
  labs(title = "Distribution of characteristics across clusters by counts", x = "Cluster number", y = NULL) +
  scale_fill_viridis(option="magma", begin = 0.2, end = 0.95)+
  facet_grid(trait~. , scales="free_y")
heatmap.c

ggsave(here('outputs_figures/clusters/prob_cluster_sep2021_simple/prob.dendro.heatcounts.aggl.k7.life.pdf'), plot=heatmap.c, width=8, height=12, dpi=300)


heatmap.p <- ggplot(prob.clust.long, aes(x = factor(prob.clust.num), y = factor(level, ordered = T))) +
  geom_tile(aes(fill = percent), alpha = 0.85)+
  labs(title = "Distribution of characteristics across clusters by percentage", x = "Cluster number", y = NULL) +
  #scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4") +
  scale_fill_viridis(option="magma", begin = 0.2, end = 0.95)+
  facet_grid(trait~., scales="free_y")
heatmap.p

ggsave(here('outputs_figures/clusters/prob_cluster_sep2021_simple/prob.dendro.heatpercent.aggl.k7.life.pdf'), plot=heatmap.p, width=8, height=12, dpi=300)

#library(plyr)

```

```{r Summary info, warning=FALSE, message=FALSE}
summary(as.factor(prob.prey.cl$prob.clust.num))

#Previous version prob_divis_simple
#clusters  1  2  3  4  5  6  7 
#         31 36 26 21  8 21 13 

#Sep 2021 version using gregarious as trait
#clusters  1  2  3  4  5  6  7 
#         40 27 45 24 15  2  5 

#Sep 2021 version not gregarious as trait
#clusters   1  2  3  4  5  6  7 
#          31 21 27 22  8 28 21 

#Simplified version
#clusters    1  2  3  4  5  6  7 
#           38 14 42 19 28  9  6 
```


## NMDS for checking on our ordination - divisive

Here we want to visualise species' occupancy of trait-based cluster in multivariate space. Species have been treated as sites and their trait occupancy as 'species' in the ordination and nMDS routines. Thus their position in multivariate space is based off similar and dissimilar trait values. We then overlay their cluster number graphically.

### Ordination

```{r nMDS dissimilarity, tidy=TRUE, warning=FALSE, message=FALSE, results='hide'}
#### nMDS for dissimilarity
trait_NMDS_prob <- metaMDS(prob.gower.dist, trymax = 1000) #solution after 541 iterations
trait_NMDS_prob[["stress"]] #stress = 0.1477077 #reasonable

```

### Extract NMDS coordinates and associate with co-variates/grouping factors

```{r Data scores for plotting, warning=FALSE, message=FALSE}

#Extract NMDS coordinates and associate with co-variates/grouping factors

#Using the scores function from vegan to extract the site scores and convert to a data.frame
data.scores <- as.data.frame(scores(trait_NMDS_prob))  #, "species"

#create a column of site names, from the rownames of data.scores
data.scores$points <- rownames(data.scores)

#bind treatment labels and score values
treatment.scores <- cbind(prob.prey.cl, data.scores)

#Check
#str(treatment.scores)  
#Awesome

```

### Convex hull calculations

For each ordination and set of grouping variables input to data scores chunk.

```{r Convex hulls by cluster number, warning=FALSE, message=FALSE}
#Create convex hulls for the space occupied by each cluster value
unique(treatment.scores$prob.clust.num)
length(treatment.scores$prob.clust.num)

#Cluster number - hull loop
clust = as.character(unique(treatment.scores$prob.clust.num))
for(i in 1:length(clust)) {
  temp = clust[i]
  df = treatment.scores[treatment.scores$prob.clust.num == temp, ][chull(treatment.scores[treatment.scores$prob.clust.num == temp, c("NMDS1", "NMDS2")]), ]
  assign(paste0('grp.',temp), df)
}

#combine the hull data
hull.data <- rbind(grp.1, grp.2, grp.3, grp.4, grp.5, grp.6, grp.7)  

#str(hull.data)

```

### NMDS plot

```{r nMDS Cluster Number, warning=FALSE, message=TRUE}
#nMDS plot for the assessmenet of global change (yes/no) and the drivers.
#as.integer(unique(treatment.scores$adult.clust.num))

trait_nMDS_prob_fig <- ggplot() + 
  geom_polygon(data=hull.data, 
               aes(x=NMDS1, y=NMDS2, 
                   fill= prob.clust.num, 
                   group= prob.clust.num), 
               alpha=0.30) + # add the convex hulls
  geom_point(data=treatment.scores, 
             aes(x=NMDS1, y=NMDS2, colour= prob.clust.num), 
             size=2) + # add the point markers
  coord_equal() +
  theme_bw()  +
  theme(axis.text.x = element_blank(),  # remove x-axis text
        axis.text.y = element_blank(), # remove y-axis text
        axis.ticks = element_blank(),  # remove axis ticks
        axis.title.x = element_text(size=18), # remove x-axis labels
        axis.title.y = element_text(size=18), # remove y-axis labels
        legend.title = element_text(size = 18), 
        legend.text = element_text(size = 18),
        legend.justification = c(0,0.5),
        #panel.background = element_rect(fill = "lightgrey"), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank()) +
  scale_colour_viridis(option="magma", begin = 0.8, end = 0.2, name = "Cluster Number") + 
  scale_fill_viridis(option="magma", begin = 0.8, end = 0.2, name = "Cluster Number") #+
  
trait_nMDS_prob_fig

#ggsave(here("outputs_figures/clusters/prob_cluster_sep2021_simpleg/trait_nMDS_prob_clusters.png"), 
#       plot = trait_nMDS_prob_fig, width = 8, height = 8, dpi = 300)

```

```{r nMDS Cluster by FO, warning=FALSE, message=TRUE, eval=FALSE, include=FALSE}

trait_nMDS_prob_fo <- ggplot() + 
  geom_polygon(data=hull.data, 
               aes(x=NMDS1, y=NMDS2, 
                   fill= prob.clust.num, 
                   group= prob.clust.num), 
               alpha=0.30) + # add the convex hulls
  geom_point(data=treatment.scores, 
             aes(x=NMDS1, y=NMDS2, colour= maxFO), 
             size=3) + # add the point markers
  #geom_text(data=hull.data, 
  #          aes(x=NMDS1, y=NMDS2, label = prob.clust.num)) +
  coord_equal() +
  theme_bw()  +
  theme(axis.text.x = element_blank(),  # remove x-axis text
        axis.text.y = element_blank(), # remove y-axis text
        axis.ticks = element_blank(),  # remove axis ticks
        axis.title.x = element_text(size=18), # remove x-axis labels
        axis.title.y = element_text(size=18), # remove y-axis labels
        legend.title = element_text(size = 18), 
        legend.text = element_text(size = 18),
        legend.justification = c(0,0.5),
        #panel.background = element_rect(fill = "lightgrey"), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank()) +
  scale_colour_viridis(option="magma", begin = 0, end = 1, name = "Frequency of Occurrence (%)") + 
  scale_fill_viridis(option="magma", begin = 0.9, end = 0, name = "Cluster Number") #+
  
trait_nMDS_prob_fo


#ggsave(here("outputs_figures/clusters/trait_nMDS_prob_fo.png"), 
#       plot = trait_nMDS_prob_fo, width = 8, height = 8, dpi = 300)

```

